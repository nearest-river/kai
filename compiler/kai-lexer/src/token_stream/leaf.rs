
use crate::token::*;


// This thing is a zero-cost abstarction.
#[kai_lexer_macro::impl_token_debug]
#[derive(Clone)]
pub enum Leaf {
  // wtf?
  Ident(Ident),
  Comment(Comment),
  Illegal(Illegal),

  // literals
  Str(Str),
  Char(Char),
  Bool(Bool),
  Float(Float),
  Int(Int),

  // weird stuff
  // Eof,
  Unsafe(Unsafe),
  Super(Super),
  This(This),

  // Punctuations
  At(At),
  And(And),
  AndAnd(AndAnd),
  AndEq(AndEq),
  Caret(Caret),
  CaretEq(CaretEq),
  Colon(Colon),
  Comma(Comma),
  Dollar(Dollar),
  Dot(Dot),
  DotDot(DotDot),
  DotDotDot(DotDotDot),
  DotDotEq(DotDotEq),
  Equal(Equal),
  EqualEqual(EqualEqual),
  FatArrow(FatArrow),
  Ge(Ge),
  Gt(Gt),
  Le(Le),
  Lt(Lt),
  LArrow(LArrow),
  Minus(Minus),
  MinusEq(MinusEq),
  NotEq(NotEq),
  Not(Not),
  Or(Or),
  OrEq(OrEq),
  OrOr(OrOr),
  PathSep(PathSep),
  Percent(Percent),
  PercentEq(PercentEq),
  Plus(Plus),
  PlusEq(PlusEq),
  Pound(Pound),
  Question(Question),
  RArrow(RArrow),
  SemiColon(SemiColon),
  Shl(Shl),
  Shr(Shr),
  ShlEq(ShlEq),
  ShrEq(ShrEq),
  Slash(Slash),
  SlashEq(SlashEq),
  Star(Star),
  StarEq(StarEq),

  Underscore(Underscore),

  // keywords
  As(As),
  In(In),
  Fn(Fn),
  Struct(Struct),
  Const(Const),
  Let(Let),
  Static(Static),
  Enum(Enum),
  Impl(Impl),
  Trait(Trait),
  Async(Async),
  Type(Type),
  Extern(Extern),
  Mod(Mod),
  Use(Use),
  Default(Default),
  Dyn(Dyn),
  Ref(Ref),
  Pub(Pub),

  // Control Flow,
  Break(Break),
  Continue(Continue),
  Return(Return),
  Yeet(Yeet),
  Await(Await),

  If(If),
  Else(Else),
  Match(Match),
  While(While),
  For(For),
  Loop(Loop),
  Macro(Macro),
  Move(Move),
  Mut(Mut),
  Raw(Raw),
  SelfType(SelfType),
  SelfValue(SelfValue),
  Typeof(Typeof),
  Union(Union),
  Where(Where),
  Yield(Yield),
}

impl Leaf {
  #[inline]
  pub fn try_from(token: Token)-> Option<Leaf> {
    token.into()
  }
}


impl From<Token> for Option<Leaf> {
  #[inline]
  fn from(token: Token)-> Option<Leaf> {
    let leaf=match token {
      Token::Ident(token)=> Leaf::Ident(token),
      Token::Comment(token)=> Leaf::Comment(token),
      Token::Illegal(token)=> Leaf::Illegal(token),
      Token::Str(token)=> Leaf::Str(token),
      Token::Char(token)=> Leaf::Char(token),
      Token::Bool(token)=> Leaf::Bool(token),
      Token::Float(token)=> Leaf::Float(token),
      Token::Int(token)=> Leaf::Int(token),
      Token::Unsafe(token)=> Leaf::Unsafe(token),
      Token::Super(token)=> Leaf::Super(token),
      Token::This(token)=> Leaf::This(token),
      Token::At(token)=> Leaf::At(token),
      Token::And(token)=> Leaf::And(token),
      Token::AndAnd(token)=> Leaf::AndAnd(token),
      Token::AndEq(token)=> Leaf::AndEq(token),
      Token::Caret(token)=> Leaf::Caret(token),
      Token::CaretEq(token)=> Leaf::CaretEq(token),
      Token::Colon(token)=> Leaf::Colon(token),
      Token::Comma(token)=> Leaf::Comma(token),
      Token::Dollar(token)=> Leaf::Dollar(token),
      Token::Dot(token)=> Leaf::Dot(token),
      Token::DotDot(token)=> Leaf::DotDot(token),
      Token::DotDotDot(token)=> Leaf::DotDotDot(token),
      Token::DotDotEq(token)=> Leaf::DotDotEq(token),
      Token::Equal(token)=> Leaf::Equal(token),
      Token::EqualEqual(token)=> Leaf::EqualEqual(token),
      Token::FatArrow(token)=> Leaf::FatArrow(token),
      Token::Ge(token)=> Leaf::Ge(token),
      Token::Gt(token)=> Leaf::Gt(token),
      Token::Le(token)=> Leaf::Le(token),
      Token::Lt(token)=> Leaf::Lt(token),
      Token::LArrow(token)=> Leaf::LArrow(token),
      Token::Minus(token)=> Leaf::Minus(token),
      Token::MinusEq(token)=> Leaf::MinusEq(token),
      Token::NotEq(token)=> Leaf::NotEq(token),
      Token::Not(token)=> Leaf::Not(token),
      Token::Or(token)=> Leaf::Or(token),
      Token::OrEq(token)=> Leaf::OrEq(token),
      Token::OrOr(token)=> Leaf::OrOr(token),
      Token::PathSep(token)=> Leaf::PathSep(token),
      Token::Percent(token)=> Leaf::Percent(token),
      Token::PercentEq(token)=> Leaf::PercentEq(token),
      Token::Plus(token)=> Leaf::Plus(token),
      Token::PlusEq(token)=> Leaf::PlusEq(token),
      Token::Pound(token)=> Leaf::Pound(token),
      Token::Question(token)=> Leaf::Question(token),
      Token::RArrow(token)=> Leaf::RArrow(token),
      Token::SemiColon(token)=> Leaf::SemiColon(token),
      Token::Shl(token)=> Leaf::Shl(token),
      Token::Shr(token)=> Leaf::Shr(token),
      Token::ShlEq(token)=> Leaf::ShlEq(token),
      Token::ShrEq(token)=> Leaf::ShrEq(token),
      Token::Slash(token)=> Leaf::Slash(token),
      Token::SlashEq(token)=> Leaf::SlashEq(token),
      Token::Star(token)=> Leaf::Star(token),
      Token::StarEq(token)=> Leaf::StarEq(token),
      Token::Underscore(token)=> Leaf::Underscore(token),
      Token::As(token)=> Leaf::As(token),
      Token::In(token)=> Leaf::In(token),
      Token::Fn(token)=> Leaf::Fn(token),
      Token::Struct(token)=> Leaf::Struct(token),
      Token::Const(token)=> Leaf::Const(token),
      Token::Let(token)=> Leaf::Let(token),
      Token::Static(token)=> Leaf::Static(token),
      Token::Enum(token)=> Leaf::Enum(token),
      Token::Impl(token)=> Leaf::Impl(token),
      Token::Trait(token)=> Leaf::Trait(token),
      Token::Async(token)=> Leaf::Async(token),
      Token::Type(token)=> Leaf::Type(token),
      Token::Extern(token)=> Leaf::Extern(token),
      Token::Mod(token)=> Leaf::Mod(token),
      Token::Use(token)=> Leaf::Use(token),
      Token::Default(token)=> Leaf::Default(token),
      Token::Dyn(token)=> Leaf::Dyn(token),
      Token::Ref(token)=> Leaf::Ref(token),
      Token::Pub(token)=> Leaf::Pub(token),
      Token::Break(token)=> Leaf::Break(token),
      Token::Continue(token)=> Leaf::Continue(token),
      Token::Return(token)=> Leaf::Return(token),
      Token::Yeet(token)=> Leaf::Yeet(token),
      Token::Await(token)=> Leaf::Await(token),
      Token::If(token)=> Leaf::If(token),
      Token::Else(token)=> Leaf::Else(token),
      Token::Match(token)=> Leaf::Match(token),
      Token::While(token)=> Leaf::While(token),
      Token::For(token)=> Leaf::For(token),
      Token::Loop(token)=> Leaf::Loop(token),
      Token::Macro(token)=> Leaf::Macro(token),
      Token::Move(token)=> Leaf::Move(token),
      Token::Mut(token)=> Leaf::Mut(token),
      Token::Raw(token)=> Leaf::Raw(token),
      Token::SelfType(token)=> Leaf::SelfType(token),
      Token::SelfValue(token)=> Leaf::SelfValue(token),
      Token::Typeof(token)=> Leaf::Typeof(token),
      Token::Union(token)=> Leaf::Union(token),
      Token::Where(token)=> Leaf::Where(token),
      Token::Yield(token)=> Leaf::Yield(token),
      Token::LParen(_)|Token::RParen(_)|Token::LBrace(_)|Token::RBrace(_)|Token::LBracket(_)|Token::RBracket(_)=> return None,
    };

    Some(leaf)
  }
}

impl Into<Token> for Leaf {
  #[inline]
  fn into(self)-> Token {
    match self {
      Leaf::Ident(token)=> Token::Ident(token),
      Leaf::Comment(token)=> Token::Comment(token),
      Leaf::Illegal(token)=> Token::Illegal(token),
      Leaf::Str(token)=> Token::Str(token),
      Leaf::Char(token)=> Token::Char(token),
      Leaf::Bool(token)=> Token::Bool(token),
      Leaf::Float(token)=> Token::Float(token),
      Leaf::Int(token)=> Token::Int(token),
      Leaf::Unsafe(token)=> Token::Unsafe(token),
      Leaf::Super(token)=> Token::Super(token),
      Leaf::This(token)=> Token::This(token),
      Leaf::At(token)=> Token::At(token),
      Leaf::And(token)=> Token::And(token),
      Leaf::AndAnd(token)=> Token::AndAnd(token),
      Leaf::AndEq(token)=> Token::AndEq(token),
      Leaf::Caret(token)=> Token::Caret(token),
      Leaf::CaretEq(token)=> Token::CaretEq(token),
      Leaf::Colon(token)=> Token::Colon(token),
      Leaf::Comma(token)=> Token::Comma(token),
      Leaf::Dollar(token)=> Token::Dollar(token),
      Leaf::Dot(token)=> Token::Dot(token),
      Leaf::DotDot(token)=> Token::DotDot(token),
      Leaf::DotDotDot(token)=> Token::DotDotDot(token),
      Leaf::DotDotEq(token)=> Token::DotDotEq(token),
      Leaf::Equal(token)=> Token::Equal(token),
      Leaf::EqualEqual(token)=> Token::EqualEqual(token),
      Leaf::FatArrow(token)=> Token::FatArrow(token),
      Leaf::Ge(token)=> Token::Ge(token),
      Leaf::Gt(token)=> Token::Gt(token),
      Leaf::Le(token)=> Token::Le(token),
      Leaf::Lt(token)=> Token::Lt(token),
      Leaf::LArrow(token)=> Token::LArrow(token),
      Leaf::Minus(token)=> Token::Minus(token),
      Leaf::MinusEq(token)=> Token::MinusEq(token),
      Leaf::NotEq(token)=> Token::NotEq(token),
      Leaf::Not(token)=> Token::Not(token),
      Leaf::Or(token)=> Token::Or(token),
      Leaf::OrEq(token)=> Token::OrEq(token),
      Leaf::OrOr(token)=> Token::OrOr(token),
      Leaf::PathSep(token)=> Token::PathSep(token),
      Leaf::Percent(token)=> Token::Percent(token),
      Leaf::PercentEq(token)=> Token::PercentEq(token),
      Leaf::Plus(token)=> Token::Plus(token),
      Leaf::PlusEq(token)=> Token::PlusEq(token),
      Leaf::Pound(token)=> Token::Pound(token),
      Leaf::Question(token)=> Token::Question(token),
      Leaf::RArrow(token)=> Token::RArrow(token),
      Leaf::SemiColon(token)=> Token::SemiColon(token),
      Leaf::Shl(token)=> Token::Shl(token),
      Leaf::Shr(token)=> Token::Shr(token),
      Leaf::ShlEq(token)=> Token::ShlEq(token),
      Leaf::ShrEq(token)=> Token::ShrEq(token),
      Leaf::Slash(token)=> Token::Slash(token),
      Leaf::SlashEq(token)=> Token::SlashEq(token),
      Leaf::Star(token)=> Token::Star(token),
      Leaf::StarEq(token)=> Token::StarEq(token),
      Leaf::Underscore(token)=> Token::Underscore(token),
      Leaf::As(token)=> Token::As(token),
      Leaf::In(token)=> Token::In(token),
      Leaf::Fn(token)=> Token::Fn(token),
      Leaf::Struct(token)=> Token::Struct(token),
      Leaf::Const(token)=> Token::Const(token),
      Leaf::Let(token)=> Token::Let(token),
      Leaf::Static(token)=> Token::Static(token),
      Leaf::Enum(token)=> Token::Enum(token),
      Leaf::Impl(token)=> Token::Impl(token),
      Leaf::Trait(token)=> Token::Trait(token),
      Leaf::Async(token)=> Token::Async(token),
      Leaf::Type(token)=> Token::Type(token),
      Leaf::Extern(token)=> Token::Extern(token),
      Leaf::Mod(token)=> Token::Mod(token),
      Leaf::Use(token)=> Token::Use(token),
      Leaf::Default(token)=> Token::Default(token),
      Leaf::Dyn(token)=> Token::Dyn(token),
      Leaf::Ref(token)=> Token::Ref(token),
      Leaf::Pub(token)=> Token::Pub(token),
      Leaf::Break(token)=> Token::Break(token),
      Leaf::Continue(token)=> Token::Continue(token),
      Leaf::Return(token)=> Token::Return(token),
      Leaf::Yeet(token)=> Token::Yeet(token),
      Leaf::Await(token)=> Token::Await(token),
      Leaf::If(token)=> Token::If(token),
      Leaf::Else(token)=> Token::Else(token),
      Leaf::Match(token)=> Token::Match(token),
      Leaf::While(token)=> Token::While(token),
      Leaf::For(token)=> Token::For(token),
      Leaf::Loop(token)=> Token::Loop(token),
      Leaf::Macro(token)=> Token::Macro(token),
      Leaf::Move(token)=> Token::Move(token),
      Leaf::Mut(token)=> Token::Mut(token),
      Leaf::Raw(token)=> Token::Raw(token),
      Leaf::SelfType(token)=> Token::SelfType(token),
      Leaf::SelfValue(token)=> Token::SelfValue(token),
      Leaf::Typeof(token)=> Token::Typeof(token),
      Leaf::Union(token)=> Token::Union(token),
      Leaf::Where(token)=> Token::Where(token),
      Leaf::Yield(token)=> Token::Yield(token),
    }
  }
}



